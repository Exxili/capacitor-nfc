{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { registerPlugin } from '@capacitor/core';\n\nimport type {\n  NDEFMessagesTransformable,\n  NDEFWriteOptions,\n  NFCPlugin,\n  NFCPluginBasic,\n  PayloadType,\n  TagResultListenerFunc,\n  NFCError,\n  NDEFMessages,\n} from './definitions';\n\nconst NFCPlug = registerPlugin<NFCPluginBasic>('NFC', {\n  web: () => import('./web').then((m) => new m.NFCWeb()),\n});\nexport * from './definitions';\nexport const NFC: NFCPlugin = {\n  isSupported: NFCPlug.isSupported.bind(NFCPlug),\n  startScan: NFCPlug.startScan.bind(NFCPlug),\n  cancelWriteAndroid: NFCPlug.cancelWriteAndroid.bind(NFCPlug),\n  onRead: (func: TagResultListenerFunc) => NFC.wrapperListeners.push(func),\n  onWrite: (func: () => void) => NFCPlug.addListener(`nfcWriteSuccess`, func),\n  onError: (errorFn: (error: NFCError) => void) => {\n    NFCPlug.addListener(`nfcError`, errorFn);\n  },\n  removeAllListeners: (eventName: 'nfcTag' | 'nfcError') => {\n    NFC.wrapperListeners = [];\n    return NFCPlug.removeAllListeners(eventName);\n  },\n  wrapperListeners: [],\n\n  async writeNDEF<T extends PayloadType = Uint8Array>(options?: NDEFWriteOptions<T>): Promise<void> {\n    const ndefMessage: NDEFWriteOptions<number[]> = {\n      records:\n        options?.records.map((record) => {\n          const payload: number[] | null =\n            typeof record.payload === 'string'\n              ? Array.from(new TextEncoder().encode(record.payload))\n              : Array.isArray(record.payload)\n                ? record.payload\n                : record.payload instanceof Uint8Array\n                  ? Array.from(record.payload)\n                  : null;\n\n          if (!payload) throw 'Unsupported payload type';\n\n          return {\n            type: record.type,\n            payload,\n          };\n        }) ?? [],\n    };\n\n    await NFCPlug.writeNDEF(ndefMessage);\n  },\n};\n\n// ----- Payload transformation helpers -----\ntype DecodeSpecifier = 'b64' | 'string' | 'uint8Array' | 'numberArray';\ntype decodedType<T extends DecodeSpecifier> = NDEFMessages<\n  T extends 'b64' ? string : T extends 'string' ? string : T extends 'uint8Array' ? Uint8Array : number[]\n>;\n\n// Decode a base64 string into a Uint8Array (browser-safe). Existing code used atob already.\nconst decodeBase64ToBytes = (base64Payload: string): Uint8Array => {\n  const bin = atob(base64Payload);\n  const out = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);\n  return out;\n};\n\n// Parse NFC Forum \"Text\" (Well Known 'T') records according to spec.\nconst decodeTextRecord = (bytes: Uint8Array): string => {\n  if (bytes.length === 0) return '';\n  const status = bytes[0];\n  const isUTF16 = (status & 0x80) !== 0; // Bit 7 indicates encoding\n  const langLength = status & 0x3f; // Bits 0-5 language code length\n\n  const fallbackDecodeWhole = () => {\n    try { return new TextDecoder('utf-8').decode(bytes); } catch { return Array.from(bytes).map(b=>String.fromCharCode(b)).join(''); }\n  };\n\n  if (1 + langLength > bytes.length) {\n    // Not spec-compliant; treat entire payload as plain UTF-8 text\n    return fallbackDecodeWhole();\n  }\n\n  const langBytes = bytes.slice(1, 1 + langLength);\n  // Validate language code is ASCII letters / hyphen; otherwise fallback\n  const langValid = Array.from(langBytes).every(b => (b >= 65 && b <= 90) || (b >= 97 && b <= 122) || b === 45);\n  if (!langValid) return fallbackDecodeWhole();\n\n  const textBytes = bytes.slice(1 + langLength);\n  try {\n    const decoder = new TextDecoder(isUTF16 ? 'utf-16' : 'utf-8');\n    return decoder.decode(textBytes);\n  } catch {\n    return fallbackDecodeWhole();\n  }\n};\n\n// Basic URI prefix table for Well Known 'U' records (optional convenience)\nconst URI_PREFIX: string[] = [\n  '',\n  'http://www.',\n  'https://www.',\n  'http://',\n  'https://',\n  'tel:',\n  'mailto:',\n  'ftp://anonymous:anonymous@',\n  'ftp://ftp.',\n  'ftps://',\n  'sftp://',\n  'smb://',\n  'nfs://',\n  'ftp://',\n  'dav://',\n  'news:',\n  'telnet://',\n  'imap:',\n  'rtsp://',\n  'urn:',\n  'pop:',\n  'sip:',\n  'sips:',\n  'tftp:',\n  'btspp://',\n  'btl2cap://',\n  'btgoep://',\n  'tcpobex://',\n  'irdaobex://',\n  'file://',\n  'urn:epc:id:',\n  'urn:epc:tag:',\n  'urn:epc:pat:',\n  'urn:epc:raw:',\n  'urn:epc:',\n  'urn:nfc:',\n];\n\nconst decodeUriRecord = (bytes: Uint8Array): string => {\n  if (bytes.length === 0) return '';\n  const prefixIndex = bytes[0];\n  const prefix = URI_PREFIX[prefixIndex] || '';\n  const remainder = bytes.slice(1);\n  try {\n    return prefix + new TextDecoder('utf-8').decode(remainder);\n  } catch {\n    return (\n      prefix +\n      Array.from(remainder)\n        .map((b) => String.fromCharCode(b))\n        .join('')\n    );\n  }\n};\n\nconst toStringPayload = (recordType: string, bytes: Uint8Array): string => {\n  // Well Known Text\n  if (recordType === 'T') return decodeTextRecord(bytes);\n  // Well Known URI\n  if (recordType === 'U') return decodeUriRecord(bytes);\n  // Default: attempt UTF-8 decode\n  try {\n    return new TextDecoder('utf-8').decode(bytes);\n  } catch {\n    return Array.from(bytes)\n      .map((c) => String.fromCharCode(c))\n      .join('');\n  }\n};\n\nconst coercePayloadToBytes = (p: unknown): Uint8Array => {\n  if (p instanceof Uint8Array) return p;\n  if (Array.isArray(p) && p.every((n) => typeof n === 'number')) return new Uint8Array(p as number[]);\n  if (typeof p === 'string') {\n    // Heuristic: if it's valid base64 decode it; if not, treat as UTF-8 string content\n    try {\n      if (/^[A-Za-z0-9+/=]+$/.test(p) && p.length % 4 === 0) {\n        return decodeBase64ToBytes(p);\n      }\n    } catch {/* fall through */}\n    // treat as plain string => encode\n    return new TextEncoder().encode(p);\n  }\n  return new Uint8Array();\n};\n\nconst mapPayloadTo = <T extends DecodeSpecifier>(type: T, data: NDEFMessages): decodedType<T> => {\n  return {\n    messages: data.messages.map((message) => ({\n      records: message.records.map((record) => {\n        const raw = record.payload as unknown; // base64 string originally, but be defensive\n        const bytes = coercePayloadToBytes(raw);\n        let payload: any;\n        switch (type) {\n          case 'b64': {\n            // If original was already base64, keep it; else convert bytes to base64\n            if (typeof raw === 'string' && /^[A-Za-z0-9+/=]+$/.test(raw)) {\n              payload = raw;\n            } else {\n              let bin = '';\n              for (let i = 0; i < bytes.length; i++) bin += String.fromCharCode(bytes[i]);\n              payload = btoa(bin);\n            }\n            break; }\n          case 'uint8Array':\n            payload = bytes;\n            break;\n          case 'numberArray':\n            payload = Array.from(bytes);\n            break;\n          case 'string':\n            payload = toStringPayload(record.type, bytes);\n            break;\n          default:\n            payload = raw;\n        }\n        return { type: record.type, payload };\n      }),\n    })),\n  } as decodedType<T>;\n};\n\nNFCPlug.addListener(`nfcTag`, (data) => {\n  const wrappedData: NDEFMessagesTransformable = {\n    base64() {\n      return mapPayloadTo('b64', data);\n    },\n    string() {\n      return mapPayloadTo('string', data);\n    },\n    uint8Array() {\n      return mapPayloadTo('uint8Array', data);\n    },\n    numberArray() {\n      return mapPayloadTo('numberArray', data);\n    },\n  };\n\n  for (const listener of NFC.wrapperListeners) {\n    listener(wrappedData);\n  }\n});\n"]}